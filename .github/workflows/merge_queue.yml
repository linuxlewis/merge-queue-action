name: Merge Queue

# Lightweight merge queue for GitHub Actions.
# Processes PRs labeled "queue" one at a time, in FIFO order.
#
# Usage: Add the "queue" label to an approved PR to enqueue it.
#
# Required secrets:
#   MERGE_QUEUE_APP_ID          - GitHub App ID
#   MERGE_QUEUE_APP_PRIVATE_KEY - GitHub App private key (PEM)

on:
  schedule:
    - cron: "*/5 * * * *"
  pull_request:
    types: [labeled]
  workflow_dispatch: {}

concurrency:
  group: merge-queue
  cancel-in-progress: false

jobs:
  check-queue:
    if: >
      github.event_name != 'pull_request' ||
      github.event.label.name == 'queue'
    runs-on: ubuntu-latest
    outputs:
      has_queued: ${{ steps.check.outputs.has_queued }}
    steps:
      - name: Check for queued PRs
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          COUNT=$(gh pr list --repo "$REPO" --label "queue" --state open --base master --json number --jq 'length')
          echo "has_queued=$( [ "$COUNT" -gt 0 ] && echo true || echo false )" >> "$GITHUB_OUTPUT"
          echo "Found $COUNT queued PRs"

  process-queue:
    needs: check-queue
    if: needs.check-queue.outputs.has_queued == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.MERGE_QUEUE_APP_ID }}
          private-key: ${{ secrets.MERGE_QUEUE_APP_PRIVATE_KEY }}

      - name: Process merge queue
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          echo "::group::Finding queued PRs"

          # Get all open PRs labeled "queue", sorted oldest first
          QUEUED_PRS=$(gh pr list \
            --repo "$REPO" \
            --label "queue" \
            --state open \
            --base master \
            --json number,title,labels,createdAt \
            --jq 'sort_by(.createdAt) | .[].number')

          if [ -z "$QUEUED_PRS" ]; then
            echo "No PRs in queue. Done."
            exit 0
          fi

          echo "Queued PRs (FIFO order): $QUEUED_PRS"
          echo "::endgroup::"

          # Process only the first (oldest) PR
          PR_NUM=$(echo "$QUEUED_PRS" | head -1)
          echo "::group::Processing PR #$PR_NUM"

          # Check PR is approved (at least 1 approving review)
          APPROVED=$(gh pr view "$PR_NUM" \
            --repo "$REPO" \
            --json reviewDecision \
            --jq '.reviewDecision')

          if [ "$APPROVED" != "APPROVED" ]; then
            echo "PR #$PR_NUM is not approved (status: $APPROVED). Skipping until next cycle."
            echo "::endgroup::"
            exit 0
          fi

          # Check if PR is mergeable (no conflicts)
          MERGEABLE=$(gh pr view "$PR_NUM" \
            --repo "$REPO" \
            --json mergeable \
            --jq '.mergeable')

          if [ "$MERGEABLE" = "CONFLICTING" ]; then
            echo "PR #$PR_NUM has merge conflicts. Dequeuing."
            gh pr edit "$PR_NUM" --repo "$REPO" --remove-label "queue"
            gh pr comment "$PR_NUM" --repo "$REPO" \
              --body "❌ **Merge Queue:** Removed from queue due to merge conflicts. Please resolve conflicts and re-add the \`queue\` label."
            echo "::endgroup::"
            exit 0
          fi

          # Check if branch is behind base and update it
          HEAD_REF=$(gh pr view "$PR_NUM" --repo "$REPO" --json headRefName --jq '.headRefName')
          ENCODED_HEAD_REF=$(printf '%s' "$HEAD_REF" | jq -sRr @uri)
          IS_BEHIND=$(gh api "/repos/$REPO/compare/master...$ENCODED_HEAD_REF" \
            --jq '.behind_by')

          if [ "$IS_BEHIND" -gt 0 ]; then
            echo "PR #$PR_NUM is $IS_BEHIND commits behind. Updating branch..."
            if ! gh api -X PUT "/repos/$REPO/pulls/$PR_NUM/update-branch" \
              --field expected_head_sha="$(gh pr view "$PR_NUM" --repo "$REPO" --json headRefOid --jq '.headRefOid')" \
              2>&1; then
              echo "::warning::Branch update API call failed for PR #$PR_NUM. Will retry next cycle."
            else
              echo "Branch updated. CI will re-run. Will merge on next cycle."
            fi
            echo "::endgroup::"
            exit 0
          fi

          echo "Branch is up to date."

          # Check CI status (treat empty checks as pending to avoid merging untested code)
          CI_STATE=$(gh pr checks "$PR_NUM" \
            --repo "$REPO" \
            --json name,state \
            --jq '[.[] | select(.name | startswith("Merge Queue") | not)] |
                  if length == 0 then "PENDING"
                  elif any(.state == "FAILURE" or .state == "ERROR" or .state == "CANCELLED" or .state == "TIMED_OUT" or .state == "STARTUP_FAILURE" or .state == "ACTION_REQUIRED") then "FAILURE"
                  elif any(.state == "PENDING" or .state == "QUEUED" or .state == "IN_PROGRESS") then "PENDING"
                  elif all(.state == "SUCCESS" or .state == "SKIPPED" or .state == "NEUTRAL") then "SUCCESS"
                  else "UNKNOWN" end')

          echo "CI state: $CI_STATE"

          case "$CI_STATE" in
            SUCCESS)
              echo "All checks passed! Merging PR #$PR_NUM..."
              gh pr merge "$PR_NUM" \
                --repo "$REPO" \
                --squash \
                --delete-branch
              echo "✅ PR #$PR_NUM merged successfully!"
              ;;
            PENDING)
              echo "CI still running for PR #$PR_NUM. Will retry next cycle."
              ;;
            FAILURE)
              echo "CI failed for PR #$PR_NUM. Dequeuing."
              gh pr edit "$PR_NUM" --repo "$REPO" --remove-label "queue"
              gh pr comment "$PR_NUM" --repo "$REPO" \
                --body "❌ **Merge Queue:** Removed from queue because CI checks failed. Please fix the failures and re-add the \`queue\` label."
              ;;
            *)
              echo "Unknown CI state: $CI_STATE. Will retry next cycle."
              ;;
          esac

          echo "::endgroup::"
